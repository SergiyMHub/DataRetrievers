using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text;

namespace DataRetrievers.Internal
{
    public class PredicateGuard
    {
        public static IEnumerable<ExpressionType> SupportedBinaryOperators = new[] 
        {
            ExpressionType.GreaterThan,
            ExpressionType.GreaterThanOrEqual,
            ExpressionType.LessThan,
            ExpressionType.LessThanOrEqual,
            ExpressionType.Equal,
            ExpressionType.NotEqual,
            ExpressionType.OrElse,
            ExpressionType.AndAlso,
            
        };

        public static IEnumerable<ExpressionType> SupportedComparisonOperators = new[]
        {
            ExpressionType.GreaterThan,
            ExpressionType.GreaterThanOrEqual,
            ExpressionType.LessThan,
            ExpressionType.LessThanOrEqual,
            ExpressionType.Equal,
            ExpressionType.NotEqual,
        };

        public static IEnumerable<ExpressionType> SupportedUnaryOperators = new[]
        {
            ExpressionType.Convert,
            //ExpressionType.Not,
            //ExpressionType.Call
        };

        public static IEnumerable<MethodInfo> SupportedStringFunctions = new[] {
                typeof(string).GetMethod(nameof(String.StartsWith), new [] { typeof(string)}),
                typeof(string).GetMethod(nameof(String.Contains), new [] { typeof(string)}),
        };



        /*
          Predicate = Negation | ( BoolFunctionCall | BoolProperty | BoolConstant | Comparison )
          Negation = NOT ( BoolFunctionCall | BoolProperty | BoolConstant | Comparison )
          BoolFunctionCall = StartsWithFunction | ContainsFunction
          
          StartsWithFunction: String::StartsWith StringProperty, StringConstant
          ContainsFunction: String::Contains StringProperty, StringConstant
          
          StringConstant: StringLiteral, CapturedStringVariable 
          BoolConstant: BoolLiteral, CapturedBoolVariable

          Comparison = LeftComparisonOperand ( == | != | < | > | <= | >= ) RightComparisonOperand
          LeftComparisonOperand = BoolFunctionCall | BoolProperty | BoolConstant | StringProperty | StringConstant | SimpleTypeProperty
          RightComparisonOperand = SimpleTypeLiteral | CapturedSimpleTypeConstant

          SimpleTypeLiteral = StringLiteral | BoolLiteral | NETSimpleTypeLiteral
          CapturedSimpleTypeConstant = CapturedStringVariable | CapturedBoolVariable | NETSimpleTypeCapturedVariable 

          SimpleType = SimpleTypeNullable | NETPrimitiveType | String
          SimpleTypeNullable = NULLABLE NETPrimitiveType
         

             */

        public static void PredicateIsSupported<T>(Expression<Func<T, bool>> predicate, string argumentName)
        {
            if (
                IsNegation(predicate.Body) 
                || (
                    IsBoolFunctionCall(predicate.Body) 
                    || IsBooleanProperty(predicate.Body)
                    || IsBooleanConstant(predicate.Body)
                    || IsComparison(predicate.Body)))
            {
                return;
            }

            /*if (IsBooleanConstant(predicate.Body))
            {
                return;
            }

            else if (IsBooleanCall(predicate.Body))
            {
                return;
            }
            else if (IsBooleanProperty(predicate.Body))
            {
                return;
            }
            else if (IsSupportedUnaryOperation(predicate.Body.NodeType))
            {

            }
            else if (IsSupportedComparison(predicate.Body.NodeType))
            {
                var binaryOperation = predicate.Body as BinaryExpression;
                if (IsSupportedComparisonOperand(binaryOperation.Left)
                    && IsSupportedComparisonOperand(binaryOperation.Right))
                {
                    return;
                }
            }*/
            
            throw new ArgumentException("Not supported predicate type.", argumentName);
        }

        private static bool IsNegation(Expression expr)
        {
            if (expr.NodeType == ExpressionType.Not && expr is UnaryExpression body)
            {
                return
                    IsBoolFunctionCall(body.Operand)
                    || IsBooleanProperty(body.Operand)
                    || IsBooleanConstant(body.Operand)
                    || IsComparison(body.Operand);
            }
            
            return false;
        }

        private static bool IsComparison(Expression expr)
        {
            if (expr is BinaryExpression binaryExpr && SupportedComparisonOperators.Contains(binaryExpr.NodeType))
            {
                //... left
                return (
                    IsBoolFunctionCall(binaryExpr.Left)
                    ||
                        !IsAutoGeneratedClassProperty(binaryExpr.Left) 
                        &&
                            (IsBooleanProperty(binaryExpr.Left)
                            || IsStringProperty(binaryExpr.Left)
                            || IsSimpleTypeProperty(binaryExpr.Left))
                    || IsBooleanConstant(binaryExpr.Left)
                    || IsStringConstant(binaryExpr.Left)
                //..right
                && IsSimpleTypeConstant(binaryExpr.Right));
            }
            return false;
        }

        private static bool IsAutoGeneratedClassProperty(Expression argumentExpr)
        {
            if (argumentExpr.NodeType == ExpressionType.MemberAccess && argumentExpr is MemberExpression memberExpr)
            {
                return memberExpr.Member.DeclaringType.GetCustomAttributes<CompilerGeneratedAttribute>().Any();
            }
            return false;
        }

        private static bool IsBooleanProperty(Expression expr)
        {
            return IsSimpleTypeProperty(expr) && expr.Type == typeof(bool);
        }

        private static bool IsBoolFunctionCall(Expression expr)
        {
            return IsStringFunction(expr);
        }

        //...
        private static bool IsStringFunction(Expression expr)
        {
            if (expr is MethodCallExpression callExpr 
                && IsStringProperty(callExpr.Object) 
                && SupportedStringFunctions.Contains(callExpr.Method))
            {
                var argumentExpr = callExpr.Arguments.Single();
                return IsStringConstant(argumentExpr);
            }
            return false;
        }
        //...
        private static bool IsStringProperty(Expression argumentExpr)
        {
            return IsSimpleTypeProperty(argumentExpr) && argumentExpr.Type == typeof(String);
        }

        //...
        private static bool IsStringConstant(Expression argumentExpr)
        {
            return IsSimpleTypeConstant(argumentExpr) && argumentExpr.Type == typeof(String);
        }

        //...
        private static bool IsSimpleTypeConstant(Expression argumentExpr)
        {
            if (argumentExpr.NodeType == ExpressionType.Constant && argumentExpr is ConstantExpression constantExpr)
            {
                return IsSimpleType(constantExpr.Type) || IsSimpleNullableType(constantExpr.Type);
            }
            if (argumentExpr.NodeType == ExpressionType.MemberAccess && argumentExpr is MemberExpression memberExpr)
            {
                return memberExpr.Member.DeclaringType.GetCustomAttributes<CompilerGeneratedAttribute>().Any()
                    && (IsSimpleType(memberExpr.Type) || IsSimpleNullableType(memberExpr.Type));
            }
            if (argumentExpr.NodeType == ExpressionType.Convert && argumentExpr is UnaryExpression unaryExpr)
            {
                return IsSimpleType(unaryExpr.Type) || IsSimpleNullableType(unaryExpr.Type);
            }
            return false;
        }
        //...
        private static bool IsBooleanConstant(Expression expr)
        {
            return IsSimpleTypeConstant(expr) && expr.Type == typeof(bool);
        }

        //private static bool IsSupportedComparisonOperand(Expression expr)
        //{
        //    return IsSimpleTypeProperty(expr) || IsSimpleTypeConstant(expr) || IsStringFunction(expr);
        //}

        //private static bool IsStringFunction(Expression expr)
        //{
        //    if (expr.Type == typeof(bool) && expr.NodeType == ExpressionType.Call)
        //    {
        //        var callExpr = expr as MethodCallExpression;
        //        if (SupportedStringFunctions.Contains(callExpr.Method))
        //        {
        //            var argumentExpr = callExpr.Arguments.Single();
        //            return IsSimpleTypeConstant(argumentExpr) || IsSimpleTypeProperty(argumentExpr);
        //        }
        //    }
        //    return false;
        //}

        

        private static bool IsSimpleTypeProperty(Expression expr)
        {
            const MemberTypes fieldOrProperty = MemberTypes.Field | MemberTypes.Property;
            if (expr is MemberExpression memberExpr)
            {
                if (
                    (memberExpr.Member.MemberType & fieldOrProperty) != 0
                    && (IsSimpleType(memberExpr.Type) || IsSimpleNullableType(memberExpr.Type)))
                {
                    return true;
                }
            }

            return false;
        }

        private static bool IsSimpleNullableType(Type type)
        {
            return
                type.IsGenericType 
                && type.GetGenericTypeDefinition() == typeof(Nullable<>)
                && IsSimpleType(type.GetGenericArguments().Single());
        }

        private static bool IsSimpleType(Type type)
        {
            return type.IsPrimitive || type == typeof(string);
        }
    }
}
